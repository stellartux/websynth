import { Note } from './note.js'

/** A note whose sound is generated by multiple OscillatorNodes
 * @param {Object[]} [oscParams] array of oscillator specific options
 * @param {number} [oscParams[].detune=0] detune amount of the oscillator in cents
 * @param {number} [oscParams[].frequency=440] frequency of the oscillator in Hertz
 * @param {number} [oscParams[].gain=0.5] gain of the oscillator, 0 to 1 inclusive
 * @param {string} [oscParams[].type='sine'] waveform shape, options are "sine", "square", "sawtooth", "triangle", "custom"
 * @param {number[]} [oscParams[].real] the real part of the custom waveform
 * @param {number[]} [oscParams[].imag] the imaginary part of the custom waveform
 */
export class OscillatorNote extends Note {
  constructor(target, noteParams = {}, oscParams = [{}]) {
    super(target, noteParams)
    for (const p of oscParams) {
      let gainer = this.context.createGain()
      gainer.gain.value = p.gain || 0.5
      let osc = this.context.createOscillator()
      ;(osc.detune.value = p.detune || 0),
        (osc.frequency.value = p.frequency || 440.0)
      if (p.type === 'custom') {
        osc.setPeriodicWave(
          this.context.createPeriodicWave(
            new Float32Array(p.real || [0, 1]),
            new Float32Array(p.imag || [0, 0])
          )
        )
      } else {
        osc.type = p.type || 'sine'
      }
      osc.connect(gainer).connect(this.envGain)
      osc.start()
      this.oscs.push(osc)
    }
  }
}
